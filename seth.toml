# if there are no ABIs Seth will fail to initialise with Contract Store
abi_dir = "contracts/abi"
# contract bytecodes are optional, but necessary if we want to deploy them via Contract Store
bin_dir = "contracts/bin"

# Uncomment if you want to load (address -> ABI_name) mapping from a file
# It will also save any new contract deployment (address -> ABI_name) mapping there.
# This functionality is not used for simulated networks.
#contract_map_file = "deployed_contracts_mumbai.toml"

# controls which transactions are decoded/traced. Possbile values are: none, all, reverted (default).
# if transaction level doesn't match, then calling Decode() does nothing. It's advised to keep it set
# to 'reverted' to limit noise. If you combine it with 'trace_to_json' it will save all possible data
# in JSON files for reverted transactions.
tracing_level = "reverted"
# saves each decoding/tracing results to JSON files; what exactly is saved depends on what we
# were able te decode, we try to save maximum information possible. It can either be:
# just tx hash, decoded transaction or call trace. Which transactions traces are saved depends
# on 'tracing_level'.
trace_to_json = false
# number of addresses to be generated and runtime, if set to 0, no addresses will be generated
# each generated address will receive a proportion of native tokens from root private key's balance
# with the value equal to (root_balance / ephemeral_addresses_number) - transfer_fee * ephemeral_addresses_number
ephemeral_addresses_number = 0

# If enabled we will panic when getting transaction options if current key/address has a pending transaction
# That's because the one we are about to send would get queued, possibly for a very long time. It's best to disable
# it when running load tests.
pending_nonce_protection_enabled = false

# Amount to be left on root key/address, when we are using ephemeral addresses. It's the amount that will not
# be divided into ephemeral keys.
root_key_funds_buffer = 10 # 10 eth

# feature-flagged expriments; first one sets funds return priority to 'slow' (core only!), second one
# sets the tip/base fee to the higher value in case there's 3+ orders of magnitude difference between them
experiments_enabled = ["slow_funds_return", "eip_1559_fee_equalizer"]

[nonce_manager]
key_sync_rate_limit_per_sec = 10
key_sync_timeout = "20s"
key_sync_retry_delay = "1s"
key_sync_retries = 10

[[networks]]
name = "Anvil"
chain_id = "31337"
transaction_timeout = "30s"
urls_secret = ["ws://localhost:8545"]
transfer_gas_fee = 21_000
gas_limit = 10_000_000
# legacy transactions
gas_price = 1_000_000_000
# EIP-1559 transactions
#eip_1559_dynamic_fees = true
gas_fee_cap = 1_000_000_000
gas_tip_cap = 1_000_000_000

[[networks]]
name = "Geth"
chain_id = "1337"
transaction_timeout = "30s"
urls_secret = ["ws://localhost:8546"]
transfer_gas_fee = 21_000
gas_limit = 8_000_000
# legacy transactions
gas_price = 1_000_000_000
# EIP-1559 transactions
#eip_1559_dynamic_fees = true
gas_fee_cap = 10_000_000_000
gas_tip_cap = 3_000_000_000

[[networks]]
name = "Fuji"
chain_id = "43113"
transaction_timeout = "30s"
eip_1559_dynamic_fees = true

# automated gas estimation
gas_estimation_enabled = true
gas_estimation_blocks = 100
gas_estimation_tx_priority = "standard"

# gas limits
transfer_gas_fee = 21_000
# gas limit should be explicitly set only if you are connecting to a node that's incapable of estimating gas limit itself (should only happen for very old versions)
# gas_limit = 8_000_000

# manual settings, used when gas_estimation_enabled is false or when it fails
# legacy transactions
gas_price = 30_000_000_000
# EIP-1559 transactions
gas_fee_cap = 30_000_000_000
gas_tip_cap = 1_800_000_000


[[networks]]
name = "Sepolia"
chain_id = "11155111"
transaction_timeout = "30s"
eip_1559_dynamic_fees = true

# automated gas estimation
gas_estimation_enabled = true
gas_estimation_blocks = 100
gas_estimation_tx_priority = "standard"

# gas limits
transfer_gas_fee = 21_000
# gas limit should be explicitly set only if you are connecting to a node that's incapable of estimating gas limit itself (should only happen for very old versions)
# gas_limit = 14_000_000

# manual settings, used when gas_estimation_enabled is false or when it fails
# legacy transactions
gas_price = 1_000_000_000
# EIP-1559 transactions
gas_fee_cap = 25_000_000_000
gas_tip_cap = 5_000_000_000


[[networks]]
name = "Mumbai"
chain_id = "80001"
transaction_timeout = "30s"
eip_1559_dynamic_fees = true

# automated gas estimation for live networks
# if set to true we will dynamically estimate gas for every transaction (based on suggested values, priority and congestion rate for last X blocks)
gas_estimation_enabled = true
# number of blocks to use for congestion rate estimation (it will determine buffer added on top of suggested values)
gas_estimation_blocks = 100
# transaction priority, which determines adjustment factor multiplier applied to suggested values (fast - 1.2x, standard - 1x, slow - 0.8x)
gas_estimation_tx_priority = "standard"

# gas limits
transfer_gas_fee = 21_000
# gas limit should be explicitly set only if you are connecting to a node that's incapable of estimating gas limit itself (should only happen for very old versions)
# gas_limit = 7_000_000

# manual settings, used when gas_estimation_enabled is false or when it fails
# # legacy transactions
gas_price = 30460480821
# # EIP-1559 transactions
gas_fee_cap = 1_800_000_000
gas_tip_cap = 30460480806


[[networks]]
name = "zkEVM"
chain_id = "1442"
transaction_timeout = "30s"
eip_1559_dynamic_fees = false

# automated gas estimation
gas_estimation_enabled = true
gas_estimation_blocks = 100
gas_estimation_tx_priority = "standard"

# gas limits
transfer_gas_fee = 21_000
# gas limit should be explicitly set only if you are connecting to a node that's incapable of estimating gas limit itself (should only happen for very old versions)
# gas_limit = 3_000_000

# manual settings, used when gas_estimation_enabled is false or when it fails
# legacy transactions
gas_price = 50_000_000
# EIP-1559 transactions

gas_fee_cap = 1_800_000_000
gas_tip_cap = 1_800_000_000
